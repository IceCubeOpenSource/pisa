# This service will perform the oscillation probability calculations on a grid
# of high resolution fine energy/coszen maps using a GPU-based implementation of
# the oscillation probability calculation.
#
# author: Timothy C. Arlen
#         tca3@psu.edu
#
# date:   26 Feb 2015
#
# NOTE: 2015-05-21 (TCA) attempted to use single precision, and at
# least on my system, I got all junk in the output of my osc prob
# maps. Unfortunately, I don't want to spend the time right now to
# figure out WHY this is the case, but until someone figures this out,
# keep fType to double and np.float64.

import sys,os
import numpy as np

from pisa.stages.osc.grid_propagator.GridPropagator import GridPropagator
from pisa.utils.resources import find_resource
from pisa.utils.log import logging

# Put CUDA imports in the constructor
import pycuda.driver as cuda
import pycuda.compiler
from pycuda.compiler import SourceModule
import pycuda.autoinit

class Prob3GPU(object):
    """
    This class handles all tasks related to the oscillation
    probability calculations using the prob3_GPU oscillation code,
    which is identical to the prob3 code, but adapted for use on
    the GPU.
    """
    def __init__(self, energy, coszen, detector_depth=None, earth_model=None,
                 prop_height=None):
        """
        \params:
          * earth_model: Earth density model used for matter oscillations.
          * detector_depth: Detector depth in km.
          * prop_height: Height in the atmosphere to begin in km.
        """
        self.energy = np.array(energy)
        self.coszen = np.array(coszen)
        self.n_evts = np.uint32(len(self.energy))
        self.prop_height = prop_height
        self.earth_model = earth_model
        self.FTYPE = np.float64

        self.grid_prop  = GridPropagator(
            self.earth_model, self.FTYPE(self.coszen),
            detector_depth)

        self.initialize_kernel(detector_depth)

    def initialize_kernel(self,detector_depth):

        ###############################################
        ###### DEFINE KERNEL
        ###############################################
        kernel_template = """//CUDA//
          #include "mosc.cu"
          #include "mosc3.cu"
          #include "utils.h"
          #include "constants.h"
          #include <stdio.h>


          __global__ void propagateArray(fType* d_osc_weights,
                                        fType d_dm[3][3], fType d_mix[3][3][2],
                                        const fType* const d_energy,
                                        const int n_evts,
                                        const int maxLayers,
                                        const int* const d_numberOfLayers,
                                        const fType* const d_densityInLayer,
                                        const fType* const d_distanceInLayer)
          {

            const int idx = blockIdx.x*blockDim.x + threadIdx.x;

            // ensure we don't access memory outside of bounds!
            if(idx >= n_evts) return;

            int kNuBar;
            //if(threadIdx.z == 0) kNuBar = 1;
            if(blockIdx.z == 0) kNuBar = 1;
            else kNuBar=-1;

            bool kUseMassEstates = false;

            fType TransitionMatrix[3][3][2];
            fType TransitionProduct[3][3][2];
            fType TransitionTemp[3][3][2];
            fType RawInputPsi[3][2];
            fType OutputPsi[3][2];
            fType Probability[3][3];

            clear_complex_matrix( TransitionMatrix );
            clear_complex_matrix( TransitionProduct );
            clear_complex_matrix( TransitionTemp );
            clear_probabilities( Probability );

            int layers = *(d_numberOfLayers + idx);

            fType energy = d_energy[idx];
            for( int i=0; i<layers; i++) {
              fType density = *(d_densityInLayer + idx*maxLayers + i);
              fType distance = *(d_distanceInLayer + idx*maxLayers + i);

              get_transition_matrix( kNuBar,
                                     energy,
                                     density,
                                     distance,
                                     TransitionMatrix,
                                     0.0,
                                     d_mix,
                                     d_dm);

              if(i==0) { copy_complex_matrix(TransitionMatrix, TransitionProduct);
              } else {
                clear_complex_matrix( TransitionTemp );
                multiply_complex_matrix( TransitionMatrix, TransitionProduct, TransitionTemp );
                copy_complex_matrix( TransitionTemp, TransitionProduct );
              }
            } // end layer loop

            // loop on neutrino types, and compute probability for neutrino i:
            // We actually don't care about nutau -> anything since the flux there is zero!
            for( unsigned i=0; i<2; i++) {
              for ( unsigned j = 0; j < 3; j++ ) {
                RawInputPsi[j][0] = 0.0;
                RawInputPsi[j][1] = 0.0;
              }

              if( kUseMassEstates ) convert_from_mass_eigenstate(i+1,kNuBar,RawInputPsi,d_mix);
              else RawInputPsi[i][0] = 1.0;

              multiply_complex_matvec( TransitionProduct, RawInputPsi, OutputPsi );
              Probability[i][0] +=OutputPsi[0][0]*OutputPsi[0][0]+OutputPsi[0][1]*OutputPsi[0][1];
              Probability[i][1] +=OutputPsi[1][0]*OutputPsi[1][0]+OutputPsi[1][1]*OutputPsi[1][1];
              Probability[i][2] +=OutputPsi[2][0]*OutputPsi[2][0]+OutputPsi[2][1]*OutputPsi[2][1];

			}

            for (int i=0;i<2;i++) {
              int iMap = 0;
              if (kNuBar == 1) iMap = i*3;
              else iMap = 6 + i*3;
              for (unsigned to_nu=0; to_nu<3; to_nu++) {
                int k = (iMap+to_nu);
                fType prob = Probability[i][to_nu];
                atomicAdd((d_osc_weights + k*n_evts + idx),prob);
              }

            }
          }
        """

        include_path = os.path.expandvars('$PISA/pisa/stages/osc/grid_propagator/')
        logging.info("  pycuda INC PATH: %s"%include_path)
        logging.info("  pycuda FLAGS: %s"%pycuda.compiler.DEFAULT_NVCC_FLAGS)
        self.module = SourceModule(kernel_template,
                                   include_dirs=[include_path],
                                   keep=True)
        self.propagateArray = self.module.get_function("propagateArray")

    def prepare_device_arrays(self):

        self.maxLayers  = self.grid_prop.GetMaxLayers()
        numLayers       = np.zeros(self.n_evts,dtype=np.int32)
        densityInLayer  = np.zeros((self.n_evts*self.maxLayers),dtype=self.FTYPE)
        distanceInLayer = np.zeros((self.n_evts*self.maxLayers),dtype=self.FTYPE)

        self.grid_prop.GetNumberOfLayers(numLayers)
        self.grid_prop.GetDensityInLayer(densityInLayer)
        self.grid_prop.GetDistanceInLayer(distanceInLayer)

        # Copy all these earth info arrays to device:
        self.d_numLayers       = cuda.mem_alloc(numLayers.nbytes)
        self.d_densityInLayer  = cuda.mem_alloc(densityInLayer.nbytes)
        self.d_distanceInLayer = cuda.mem_alloc(distanceInLayer.nbytes)
        cuda.memcpy_htod(self.d_numLayers,numLayers)
        cuda.memcpy_htod(self.d_densityInLayer,densityInLayer)
        cuda.memcpy_htod(self.d_distanceInLayer,distanceInLayer)

        self.d_energy = cuda.mem_alloc(self.energy.nbytes)
        cuda.memcpy_htod(self.d_energy,self.energy)

    def run_osc(self, theta12, theta13, theta23, deltam21, deltam31,
                          deltacp, YeI, YeO, YeM):
        """
        Returns an oscillation probability map dictionary calculated
        at the values of the input parameters:
          deltam21,deltam31,theta12,theta13,theta23,deltacp
        for flavor_from to flavor_to, with the binning defined in the constructor.
        The dictionary is formatted as:
          'nue_maps': {'nue':map,'numu':map,'nutau':map},
          'numu_maps': {...}
          'nue_bar_maps': {...}
          'numu_bar_maps': {...}

        \params:
          * theta12,theta13,theta23 - in [rad]
          * deltam21, deltam31 - in [eV^2]
        """

        sin2th12Sq = np.sin(theta12)**2
        sin2th13Sq = np.sin(theta13)**2
        sin2th23Sq = np.sin(theta23)**2

        mAtm = deltam31 if deltam31 < 0.0 else (deltam31 - deltam21)

        # Comment BargerPropagator.cc::SetMNS()
        # "For the inverted Hierarchy, adjust the input
        # by the solar mixing (should be positive)
        # to feed the core libraries the correct value of m32."
        #if mAtm < 0.0: mAtm -= deltam21;

        self.grid_prop.SetMNS(deltam21,mAtm,sin2th12Sq,sin2th13Sq,sin2th23Sq,deltacp)
        self.grid_prop.SetEarthDensityParams(self.prop_height,YeI,YeO,YeM)
        self.prepare_device_arrays()

        dm_mat = np.zeros((3,3),dtype=self.FTYPE)
        self.grid_prop.Get_dm_mat(dm_mat)
        mix_mat = np.zeros((3,3,2),dtype=self.FTYPE)
        self.grid_prop.Get_mix_mat(mix_mat)

        logging.debug("dm_mat: \n %s"%str(dm_mat))
        logging.debug("mix[re]: \n %s"%str(mix_mat[:,:,0]))

        d_dm_mat = cuda.mem_alloc(dm_mat.nbytes)
        d_mix_mat = cuda.mem_alloc(mix_mat.nbytes)
        cuda.memcpy_htod(d_dm_mat,dm_mat)
        cuda.memcpy_htod(d_mix_mat,mix_mat)

        osc_weights = np.zeros((self.n_evts*12),dtype=self.FTYPE)
        d_osc_weights = cuda.mem_alloc(osc_weights.nbytes)
        cuda.memcpy_htod(d_osc_weights,osc_weights)

        bdim = (256,1,1)
        dx, mx = divmod(self.n_evts, bdim[0])
        gdim = ((dx + (mx>0)) * bdim[0], 1)

        self.propagateArray(d_osc_weights,
                      d_dm_mat, d_mix_mat,
                      self.d_energy,
                      self.n_evts,
                      np.uint32(self.maxLayers),
                      self.d_numLayers, self.d_densityInLayer,
                      self.d_distanceInLayer,
                      block=bdim, grid=gdim)

        cuda.memcpy_dtoh(osc_weights,d_osc_weights)

        osc_weights = np.reshape(osc_weights,(12,self.n_evts))
        #flavs = ['nue','numu','nutau']
        #iMap = 0
        #for from_nu in ['nue','numu','nue_bar','numu_bar']:
        #    from_nu += '_maps'
        #    smoothed_maps[from_nu] = {}
        #    for to_nu in flavs:
        #        if '_bar' in from_nu: to_nu+='_bar'
        #        smoothed_maps[from_nu][to_nu] = osc_weights[iMap]
        #        iMap+=1

        return osc_weights



if __name__ == '__main__':

    energy = np.linspace(1,100,100)
    coszen = np.linspace(-1,1,100)
    
    detector_depth = 2.0
    earth_model = find_resource('osc/PREM_12layer.dat')
    prop_height = 20.0

    osc = Prob3GPU(energy, coszen, detector_depth, earth_model, prop_height)

    theta12 = 0.5839958715755919
    theta13 = 0.14819001778459273
    theta23 = 0.7373241279447564
    deltam21 = 7.5e-05
    deltam31 = 0.002457
    deltacp = 5.340707511102648
    YeI = 0.4656
    YeO = 0.4656
    YeM = 0.4957

    weights = osc.run_osc(theta12, theta13, theta23, deltam21, deltam31,
                          deltacp, YeI, YeO, YeM)

    print weights
