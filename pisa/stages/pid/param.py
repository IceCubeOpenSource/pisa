#
# PISA authors: Lukas Schulte
#               schulte@physik.uni-bonn.de
#               Justin L. Lanfranchi
#               jll1062+pisa@phys.psu.edu
#
# CAKE authors: Shivesh Mandalia
#               s.p.mandalia@qmul.ac.uk
#
# date:    2016-05-13
"""
The purpose of this stage is to simulate event classification sorting the
reconstructed particles into PID-signature channels.

For each PID signature, the input map is transformed by the probability for
events in each of its bins to be ID'd as that signature. Therefore the ouptut
binning is similar to the input binning, but with the added 'pid' dimension,
which has as many bins as PID signatures.
"""


from collections import Mapping, OrderedDict
from copy import deepcopy
from itertools import product

import numpy as np

# Note the following imports are liberal to allow for more flexible PID
# parameterization strings specs
from numpy import *
import scipy as sp
from scipy.stats import *

from pisa.core.binning import OneDimBinning
from pisa.core.map import Map, MapSet
from pisa.core.stage import Stage
from pisa.core.transform import BinnedTensorTransform, TransformSet
from pisa.utils.fileio import from_file
from pisa.utils.flavInt import flavintGroupsFromString, NuFlavIntGroup
from pisa.utils.hash import hash_obj
from pisa.utils.log import logging
from pisa.utils.profiler import profile


__all__ = ['param']


class param(Stage):
    """Parameterised MC PID based on an input json file containing functions
    describing the PID as a function of energy.

    Transforms an input map of the specified particle "signature" (aka ID) into
    a map of the track-like events ('track') and a map of the shower-like events
    ('cascade').

    Parameters
    ----------
    params : ParamSet or sequence with which to instantiate a ParamSet

        Parameters which set everything besides the binning.

        If str, interpret as resource location and load params from resource.
        If dict, set contained params. Format expected is
            {'<param_name>': <Param object or passable to Param()>}

        Parameters required by this service are
            * pid_energy_paramfile : dict or filepath
                json file or equivalent dict containing the PID functions for
                each flavor. The structure should be:
                  {
                    "numu_cc + numubar_cc": {
                      "track" : "lambda E: some function",
                      "cascade" : "lambda E: 1 - some function"
                    },
                    "nue_cc + nuebar_cc": {
                      "track" : "lambda E: some function",
                      "cascade" : "lambda E: 1 - some function"
                    },
                    "nutau_cc + nutaubar_cc": {
                      "track" : "lambda E: some function",
                      "cascade" : "lambda E: 1 - some function"
                    },
                    "nuall_nc + nuallbar_nc": {
                      "track" : "lambda E: some function",
                      "cascade" : "lambda E: 1 - some function"
                    }
                  }

    particles : string

    input_names : sequence of strings

    transform_groups

    sum_grouped_flavints : bool

    input_binning : MultiDimBinning
        Arbitrary number of dimensions accepted. Contents of the input
        `pid_events` parameter defines the possible binning dimensions. Name(s)
        of given binning(s) must match to a reco variable in `pid_events`.

    output_binning : MultiDimBinning

    error_method : None, bool, or string

    transforms_cache_depth : int >= 0

    outputs_cache_depth : int >= 0

    memcache_deepcopy : bool

    debug_mode : None, bool, or string
        Whether to store extra debug info for this service.


    Input Names
    ----------
    The `inputs` container must include objects with `name` attributes:
        * 'nue_cc'
        * 'nuebar_cc'
        * 'numu_cc'
        * 'numubar_cc'
        * 'nutau_cc'
        * 'nutaubar_cc'
        * 'nuall_nc'
        * 'nuallbar_nc'

    Output Names
    ----------
    The `outputs` container generated by this service will be objects with the
    following `name` attribute; pid is added as a binning dimension:
        * 'nue_cc'
        * 'nuebar_cc'
        * 'numu_cc'
        * 'numubar_cc'
        * 'nutau_cc'
        * 'nutaubar_cc'
        * 'nuall_nc'
        * 'nuallbar_nc'

    """
    def __init__(self, params, particles, input_names, transform_groups,
                 sum_grouped_flavints, input_binning, output_binning,
                 memcache_deepcopy, error_method, transforms_cache_depth,
                 outputs_cache_depth, debug_mode=None):
        assert particles in ['muons', 'neutrinos']
        self.particles = particles.strip().lower()
        """Whether stage is instantiated to process neutrinos or muons"""

        self.transform_groups = flavintGroupsFromString(transform_groups)
        """Particle/interaction types to group for computing transforms"""

        self.sum_grouped_flavints = sum_grouped_flavints

        # All of the following params (and no more) must be passed via
        # the `params` argument.
        expected_params = (
            'pid_energy_paramfile'
        )

        if isinstance(input_names, basestring):
            input_names = input_names.replace(' ', '').split(',')

        self.signatures = output_binning.pid.bin_names
        """PID signatures that this stage generates"""

        # If no bin names are present, use the integer bin indices instead
        if self.signatures is None:
            self.signatures = range(len(output_binning.pid))

        if self.particles == 'neutrinos':
            if self.sum_grouped_flavints:
                output_names = [str(g) for g in self.transform_groups]
            else:
                output_names = input_names
        elif self.particles == 'muons':
            raise NotImplementedError('%s not implemented.' % self.particles)

        super(self.__class__, self).__init__(
            use_transforms=True,
            params=params,
            expected_params=expected_params,
            input_names=input_names,
            output_names=input_names,
            error_method=error_method,
            outputs_cache_depth=outputs_cache_depth,
            transforms_cache_depth=transforms_cache_depth,
            memcache_deepcopy=memcache_deepcopy,
            input_binning=input_binning,
            output_binning=output_binning,
            debug_mode=debug_mode
        )

        self.include_attrs_for_hashes('particles')
        self.include_attrs_for_hashes('sum_grouped_flavints')
        self.include_attrs_for_hashes('transform_groups')

        # Define the transform binnning...

        # Note that Numpy broadcasting rules start with last axis and work
        # inwards. We want the input map (say MxN) to automatically be
        # broadcast to multiply into each of L PID bins. Therefore, if
        # we _prepend_ the PID dimension to the transform, we have an MxN input
        # multiplying an LxMxN transform, and Numpy treats this as L separate
        # MxN by MxN multiplies which populate an output array of dimension
        # LxMxN... exactly what we want, and with maximal computational
        # efficiency (for Numpy to handle, at least). If the user's output
        # binning does not follow the same ordering, this is okay, as the
        # output is passed through the `rebin` function each time it is
        # computed, and this takes care of any axis swapping necessary.

        self.transform_output_binning = self.output_binning.pid * self.input_binning

        self.energy_param_dict = None
        self._energy_param_hash = None

    def validate_binning(self):
        """Validate input and output binning"""
        required_input_binning_dims = 'reco_energy', 'reco_coszen'
        required_output_binning_dims = 'reco_energy', 'reco_coszen', 'pid'

        msg = ('%s binning must contain dimensions %s, but has dimensions %s'
               ' instead.')

        if set(self.input_binning.names) != set(required_input_binning_dims):
            raise ValueError(msg % ('Input', required_input_binning_dims,
                                    self.input_binning.names))

        if set(self.output_binning.names) != set(required_output_binning_dims):
            raise ValueError(msg % ('Output', required_input_binning_dims,
                                    self.input_binning.names))

        # While output binning will have a 'pid' dimension, the remaining
        # dimensions must be the same in both input and output binnings
        for dim in self.input_binning.dims:
            if not dim == self.output_binning[dim.name]:
                raise NotImplementedError(
                    'Input and output dimensions %s are not equal, but stage'
                    ' %s / service %s does not implement binning up- or'
                    ' downsampling.'
                    % (dim.name, self.stage_name, self.service_name)
                )

    def load_pid_energy_param(self, pid_energy_param):
        """Load pid energy-dependent parameterisation from file or dictionary.

        Parameters
        ----------
        pid_energy_param : string
            Resource location of the file

        """
        this_hash = hash_obj(pid_energy_param)
        if (self._energy_param_hash is not None
                and this_hash == self._energy_param_hash):
            return

        # Invalidate the hash and clear the entry, so we aren't left in an
        # inconsistent state if any of the below fails
        self._energy_param_hash = None
        self.energy_param_dict = None

        # Get the original dict
        if isinstance(pid_energy_param, basestring):
            orig_dict = from_file(pid_energy_param)
        elif isinstance(pid_energy_param, Mapping):
            orig_dict = pid_energy_param

        # Perform validation
        for key, val in orig_dict.iteritems():
            # Each item itself should be a dict...
            if not isinstance(val, Mapping):
                raise TypeError(
                    "Loaded energy PID parameterisation should be a mapping"
                    " but got '%s.'" % type(val)
                )

            # ...with keys the same names as the PID signatures
            if set(val.keys()) != set(self.signatures):
                raise ValueError(
                    'Expected PID specs for %s, but the energy PID'
                    ' parameterisation for %s specifies %s instead.'
                    % (self.signatures, key, val.keys())
                )

        #  Build dict with flavintgroups as keys
        flavintgroup_dict = OrderedDict()
        for key, val in orig_dict.iteritems():
            flavintgroup_dict[NuFlavIntGroup(key)] = val

        # Transform groups are implicitly defined by the contents of the
        # `pid_energy_paramfile`'s keys
        implicit_transform_groups = flavintgroup_dict.keys()

        # Make sure these match the transform groups specified for the stage
        if set(implicit_transform_groups) != set(self.transform_groups):
            raise ValueError(
                'Transform groups (%s) defined implicitly by'
                ' `pid_energy_paramfile` "%s" do not match those defined'
                ' as the stage `transform_groups` (%s).'
                % (implicit_transform_groups, pid_energy_param,
                   self.transform_groups)
            )

        # Verify that each input name--which specifies a flavint or
        # flavintgroup--is wholly encapsulated by one of the transform
        # flavintgroups
        for name in self.input_names:
            if not any(name in group for group in implicit_transform_groups):
                raise ValueError(
                    'Input "%s" either not present in or spans multiple'
                    ' transform groups (transform_groups = %s)'
                    % (name, implicit_transform_groups)
                )

        # Create dict with one parameterization for _each_ NuFlavInt,
        # duplicating parameterization specs as necessary
        energy_param_dict = OrderedDict()
        for flavintgroup, val in flavintgroup_dict.iteritems():
            for flavint in flavintgroup:
                energy_param_dict[flavint] = val

        self.energy_param_dict = energy_param_dict
        self._energy_param_hash = this_hash

    @profile
    def _compute_nominal_transforms(self):
        """Compute new PID transforms."""
        logging.debug('Updating pid.param PID histograms...')

        self.load_pid_energy_param(self.params.pid_energy_paramfile.value)
        ecen = self.transform_output_binning.reco_energy.weighted_centers.m_as('GeV')

        nominal_transforms = []
        for xform_flavints in self.transform_groups:
            logging.debug('Working on %s PID', xform_flavints)

            xform_array = np.empty(self.transform_output_binning.shape)

            repr_flavint = xform_flavints[0]
            all_pid_param_specs = self.energy_param_dict[repr_flavint]

            for signature, sig_param_spec in all_pid_param_specs.iteritems():
                if isinstance(sig_param_spec, basestring):
                    sig_param_func = eval(sig_param_spec)
                    if not callable(sig_param_func):
                        raise ValueError(
                            'Group %s PID signature %s param spec "%s" does'
                            ' not evaluate to a callable.'
                            % (xform_flavints, signature, pid_param_spec)
                        )
                elif callable(pid_param_spec):
                    sig_param_func = pid_param_spec
                else:
                    raise TypeError(
                        'Group %s PID signature %s parameterization is a "%s"'
                        ' but must be a string or callable.'
                        % (xform_flavints, signature, type(param_spec))
                    )

                # Get the PID probabilities vs. energy at the energy bins'
                # (weighted) centers
                pid1d = sig_param_func(ecen)

                # Broadcast this 1d array across the reco_coszen dimension
                # since it's independent of reco_coszen
                broadcasted_pid = self.transform_output_binning.broadcast(
                    pid1d, from_dim='reco_energy', to_dims='reco_coszen'
                )

                # Assign the broadcasted array to the appropriate PID bin
                pid_indexer = self.transform_output_binning.defaults_indexer(pid=signature)
                xform_array[pid_indexer] = broadcasted_pid

            if self.sum_grouped_flavints:
                xform_input_names = []
                for input_name in self.input_names:
                    input_flavs = NuFlavIntGroup(input_name)
                    if set(xform_flavints).intersection(input_flavs):
                        xform_input_names.append(input_name)

                for output_name in self.output_names:
                    if output_name not in xform_flavints:
                        continue
                    xform = BinnedTensorTransform(
                        input_names=xform_input_names,
                        output_name=str(xform_flavints),
                        input_binning=self.input_binning,
                        output_binning=self.transform_output_binning,
                        xform_array=xform_array,
                        sum_inputs=self.sum_grouped_flavints
                    )
                    nominal_transforms.append(xform)
            else:
                for input_name in self.input_names:
                    if input_name not in xform_flavints:
                        continue
                    xform = BinnedTensorTransform(
                        input_names=input_name,
                        output_name=input_name,
                        input_binning=self.input_binning,
                        output_binning=self.transform_output_binning,
                        xform_array=xform_array,
                    )
                    nominal_transforms.append(xform)

        return TransformSet(transforms=nominal_transforms)

    def _compute_transforms(self):
        """There are no systematics in this stage, so the transforms are just
        the nominal transforms. Thus, this function just returns the nominal
        transforms, computed by `_compute_nominal_transforms`..
        """
        return self.nominal_transforms

    def validate_params(self, params):
        """Do checks on the parameters"""
        val = params.pid_energy_paramfile.value
        if not isinstance(val, (basestring, Mapping)):
            raise TypeError(
                'Expecting either a path to a file or a dictionary provided'
                ' as the store of the parameterisations. Got "%s".' % type(val)
            )
