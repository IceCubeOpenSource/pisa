# authors: T.Arlen, J.Lanfranchi, P.Eller
# date:   March 20, 2016

from itertools import izip, product
from operator import setitem

import numpy as np

from pisa import ureg, Q_
from pisa.core.binning import MultiDimBinning
from pisa.core.stage import Stage
from pisa.core.transform import BinnedTensorTransform, TransformSet
from pisa.utils.resources import find_resource
from pisa.stages.osc.prob3.BargerPropagator import BargerPropagator
from pisa.utils.log import logging
from pisa.utils.comparisons import normQuant
from pisa.utils.profiler import profile


SIGFIGS = 12
"""Significant figures for determining if numbers and quantities normalised
(using pisa.utils.comparisons.normQuant) are equal. Make sure this is less than
the numerical precision that calculations are being performed in to have the
desired effect that "essentially equal" things evaluate to be equal."""

# Indices that are used for transform datastructs created here and for C++
# interface to Barger propagator
NUE_IDX, NUMU_IDX, NUTAU_IDX = 0, 1, 2
INPUTS = (NUE_IDX, NUMU_IDX)
OUTPUTS = (NUE_IDX, NUMU_IDX, NUTAU_IDX)
INPUTS_OUTPUTS = tuple([x for x in product(INPUTS, OUTPUTS)])

# More Barger definitions
K_NEUTRINOS = 1
K_ANTINEUTRINOS = -1
K_SQUARED = True

class prob3cpu(Stage):
    """Neutrino oscillations calculation via Prob3.

    Parameters
    ----------
    params : ParamSet
        All of the following param names (and no more) must be in `params`.
        Earth parameters:
            * earth_model : str (resource location with earth model file)
            * YeI : float (electron fraction, inner core)
            * YeM : float (electron fraction, mantle)
            * YeO : float (electron fraction, outer core)
        Detector parameters:
            * detector_depth : float >= 0
            * prop_height
        Oscillation parameters:
            * deltacp
            * deltam21
            * deltam31
            * theta12
            * theta13
            * theta23

    input_binning : MultiDimBinning
    output_binning : MultiDimBinning
    transforms_cache_depth : int >= 0
    outputs_cache_depth : int >= 0
    debug_mode : bool

    Input Names
    -----------
    The `inputs` container must include objects with `name` attributes:
      * 'nue'
      * 'numu'
      * 'nuebar'
      * 'numubar'

    Output Names
    ------------
    The `outputs` container generated by this service will be objects with the
    following `name` attribute:
      * 'nue'
      * 'numu'
      * 'nutau'
      * 'nuebar'
      * 'numubar'
      * 'nutaubar'

    """
    def __init__(self, params, input_binning, output_binning,
                 error_method=None, transforms_cache_depth=20,
                 outputs_cache_depth=20, debug_mode=None):
        expected_params = (
            'earth_model', 'YeI', 'YeM', 'YeO',
            'detector_depth', 'prop_height',
            'deltacp', 'deltam21', 'deltam31',
            'theta12', 'theta13', 'theta23'
        )

        # Define the names of objects that are required by this stage (objects
        # will have the attribute "name": i.e., obj.name)
        input_names = (
            'nue', 'numu', 'nuebar', 'numubar'
        )

        # Define the names of objects that get produced by this stage
        output_names = (
            'nue', 'numu', 'nutau', 'nuebar', 'numubar', 'nutaubar'
        )

        assert input_binning == output_binning

        # Invoke the init method from the parent class (Stage), which does a
        # lot of work (caching, providing public interfaces, etc.)
        super(self.__class__, self).__init__(
            use_transforms=True,
            stage_name='osc',
            service_name='prob3cpu',
            params=params,
            expected_params=expected_params,
            input_names=input_names,
            output_names=output_names,
            error_method=error_method,
            disk_cache=None,
            outputs_cache_depth=outputs_cache_depth,
            transforms_cache_depth=transforms_cache_depth,
            input_binning=input_binning,
            output_binning=output_binning,
            debug_mode=debug_mode
        )

        self.compute_binning_constants()

    def compute_binning_constants(self):
        # Only works if energy and coszen are in input_binning
        if 'true_energy' not in self.input_binning \
                or 'true_coszen' not in self.input_binning:
            raise ValueError('Input binning must contain both "true_energy" and'
                             ' "true_coszen" dimensions.')

        # Not handling rebinning (or oversampling)
        assert self.input_binning == self.output_binning

        # Get the energy/coszen (ONLY) weighted centers here, since these
        # are actually used in the oscillations computation. All other
        # dimensions are ignored. Since these won't change so long as the
        # binning doesn't change, attache these to self.
        self.ecz_binning = MultiDimBinning([
            self.input_binning.true_energy.to('GeV'),
            self.input_binning.true_coszen.to('dimensionless')
        ])
        e_centers, cz_centers = self.ecz_binning.weighted_centers
        self.e_centers = e_centers.magnitude
        self.cz_centers = cz_centers.magnitude

        self.num_czbins = self.input_binning.true_coszen.num_bins

        self.e_dim_num = self.input_binning.names.index('true_energy')
        self.cz_dim_num = self.input_binning.names.index('true_coszen')

        self.extra_dim_nums = range(self.input_binning.num_dims)
        [self.extra_dim_nums.remove(d) for d in (self.e_dim_num,
                                                 self.cz_dim_num)]

    def create_transforms_datastructs(self):
        xform_shape = [3, 2] + list(self.input_binning.shape)
        nu_xform = np.empty(xform_shape)
        antinu_xform = np.empty(xform_shape)
        return nu_xform, antinu_xform

    def setup_barger_propagator(self):
        # If already instantiated with same parameters, don't instantiate again
        if (hasattr(self, 'barger_propagator')
            and hasattr(self, '_barger_earth_model')
            and hasattr(self, '_barger_detector_depth')
            and normQuant(self._barger_detector_depth, sigfigs=SIGFIGS)
                == normQuant(self.params.detector_depth.value, sigfigs=SIGFIGS)
            and self.params.earth_model.value == self._barger_earth_model):
            return

        # Some private variables to keep track of the state of the barger
        # propagator that has been instantiated, so if it is requested to be
        # instantiated again with equivalent parameters, this step can be
        # skipped (see checks above).
        self._barger_detector_depth = self.params.detector_depth.value.to('km')
        self._barger_earth_model = self.params.earth_model.value

        # TODO: can we pass kwargs to swig-ed C++ code?
        self.barger_propagator = BargerPropagator(
            find_resource(self._barger_earth_model),
            self._barger_detector_depth.magnitude
        )
        self.barger_propagator.UseMassEigenstates(False)

    def _derive_nominal_transforms_hash(self):
        """No nominal transforms implemented for this service."""
        return None

    @profile
    def _compute_transforms(self):
        """Compute oscillation transforms using Prob3 CPU code."""
        print "------------------------_COMPUTE--------------------------------"
        self.setup_barger_propagator()

        # Read parameters in, convert to the units used internally for
        # computation, and then strip the units off. Note that this also
        # enforces compatible units (but does not sanity-check the numbers).
        theta12 = self.params.theta12.value.m_as('rad')
        theta13 = self.params.theta13.value.m_as('rad')
        theta23 = self.params.theta23.value.m_as('rad')
        deltam21 = self.params.deltam21.value.m_as('eV**2')
        deltam31 = self.params.deltam31.value.m_as('eV**2')
        deltacp = self.params.deltacp.value.m_as('rad')
        YeI = self.params.YeI.value.m_as('dimensionless')
        YeO = self.params.YeO.value.m_as('dimensionless')
        YeM = self.params.YeM.value.m_as('dimensionless')
        prop_height = self.params.prop_height.value.m_as('km')

        sin2th12Sq = np.sin(theta12)**2
        sin2th13Sq = np.sin(theta13)**2
        sin2th23Sq = np.sin(theta23)**2


        total_bins = int(len(self.e_centers)*len(self.cz_centers))
        evals = np.empty(total_bins, "double")
        czvals = np.empty(total_bins, "double")
        # We use 18 since we have each 3*3 possible oscillations for neutrinos and antineutrinos.
        probList = np.empty(total_bins*18,"double")

        probList, evals, czvals = self.barger_propagator.fill_osc_prob_c(
                self.e_centers, self.cz_centers, 1.0,
                deltam21, deltam31, deltacp, prop_height, YeI,
                YeO, YeM, total_bins*18, total_bins, total_bins,
                theta12, theta13, theta23)

        ############### Fill the dictionary
        # probList contains the calculated probabilities in the following order
        # nue->nue, nue->numu, nue->nutau
        # numu->nue, numu->numu, numu->nutau
        # nutau->nue, nutau->numu, nutau->nutau
        # Likewise follow the antineutrinos and then the next batch of neutrinos
#        osc_prob_dict['nue_maps']['nue'] = probList[0::18]
#        osc_prob_dict['nue_maps']['numu'] = probList[1::18]
#        osc_prob_dict['nue_maps']['nutau'] = probList[2::18]
#        osc_prob_dict['numu_maps']['nue'] = probList[3::18]
#        osc_prob_dict['numu_maps']['numu'] = probList[4::18]
#        osc_prob_dict['numu_maps']['nutau'] = probList[5::18]
#        osc_prob_dict['nue_bar_maps']['nue_bar'] = probList[9::18]
#        osc_prob_dict['nue_bar_maps']['numu_bar'] = probList[10::18]
#        osc_prob_dict['nue_bar_maps']['nutau_bar'] = probList[11::18]
#        osc_prob_dict['numu_bar_maps']['nue_bar'] = probList[12::18]
#        osc_prob_dict['numu_bar_maps']['numu_bar'] = probList[13::18]
#        osc_prob_dict['numu_bar_maps']['nutau_bar'] = probList[14::18]

        print "Applying transforms"
        # Slice up the transform arrays into views to populate each transform
        transforms = []
        print "input_binning.shape: ", self.input_binning.shape
        xShape = [2] + list(self.input_binning.shape)
        xform = np.empty(xShape)
        print "xShape: ", xShape
        print "xformShape: ", xform.shape
        print "num_czbins: ", self.num_czbins, " starting wrapping"
        for out_idx, output_name in enumerate(self.output_names):
            print out_idx
            #out_idx = out_idx % 3
            if out_idx < 3:
                # Map to nue (0, 3), numu (1,4), nutau (2,5)
                print "probListLength: ", len(probList), "; to out_idx \
                        +18*(i+1)*self.num_czbins: ", out_idx \
                        +18*(self.num_czbins)*self.num_czbins, "; for i up to: ",  self.num_czbins
                inCzDim1 = np.array([probList[out_idx+i*self.num_czbins*18:out_idx
                        +18*(i+1)*self.num_czbins:18]
                        for i in range(0, self.num_czbins)])
                inCzDim2 = np.array([probList[out_idx+3+i*self.num_czbins*18:out_idx
                        +18*(i+1)*self.num_czbins:18]
                        for i in range(0, self.num_czbins)])
                #xform[0] = np.array([probList[out_idx+i*self.num_czbins:out_idx+18*(i+1)*self.num_czbins:18]
                #            for i in range(0, self.num_czbins)])
                #xform[1] =  np.array([probList[out_idx+3+i*self.num_czbins:out_idx+18*(i+1)*self.num_czbins:18]
                #                for i in range(0, self.num_czbins)])

                print "shape of inner array: ", inCzDim1.shape
                print "shape of inner array2: ", inCzDim2.shape
                print "xformShape: ", xform.shape
                # inCzDim1.reshape(40,40)
                xform[0] = np.array([probList[out_idx+i*self.num_czbins*18:out_idx
                            +18*(i+1)*self.num_czbins:18]
                            for i in range(0, self.num_czbins)])
                xform[1] = np.array([probList[out_idx+3+i*self.num_czbins*18:out_idx
                            +18*(i+1)*self.num_czbins:18]
                            for i in range(0, self.num_czbins)])
                #xform = [probList[out_idx::18], probList[out_idx+3::18]]

                #xform = nu_xform[out_idx, :, ...]
                input_names = self.input_names[0:2]
            else:
                # Map to nue_bar (9, 12), numu_bat (10,13), nutau_bar (11,14)
                #inCzDim1 = [probList[out_idx+6+i*self.num_czbins:out_idx+18*(i+1)*self.num_czbins:18]
                #           for i in range(0, self.num_czbins)]
                #inCzDim2 = [probList[out_idx+9+i*self.num_czbins:out_idx+18*(i+1)*self.num_czbins:18]
                #          for i in range(0, self.num_czbins)]
                # Look here: Slice is wrong

                inCzDim1 = np.array([probList[out_idx+6+i*self.num_czbins*18:out_idx
                        +6+18*(i+1)*self.num_czbins:18]
                        for i in range(0, self.num_czbins)])
                inCzDim2 = np.array([probList[out_idx+9+i*self.num_czbins*18:out_idx
                        +9+18*(i+1)*self.num_czbins:18]
                        for i in range(0, self.num_czbins)])
                xform[0] = np.array([probList[out_idx+6+i*self.num_czbins*18:out_idx
                            +6+18*(i+1)*self.num_czbins:18]
                            for i in range(0, self.num_czbins)])
                xform[1] = np.array([probList[out_idx+9+i*self.num_czbins*18:out_idx
                            +9+18*(i+1)*self.num_czbins:18]
                            for i in range(0, self.num_czbins)])
                # xform[0] = [probList[out_idx+6+i*self.num_czbins*18:out_idx+18
                #         *(i+1)*self.num_czbins:18]
                #         for i in range(0, self.num_czbins)]
                # xform[1] = [probList[out_idx+9+i*self.num_czbins*18:out_idx+18
                #         *(i+1)*self.num_czbins:18]
                #         for i in range(0, self.num_czbins)]
                #xform = np.array([inCzDim1, inCzDim2])
                #xform = [probList[out_idx+6::18], probList[out_idx+9::18]]
                # xform = antinu_xform[out_idx, :, ...]
                input_names = self.input_names[2:4]
            print "xform[", len(xform), ", ", len(xform[1]), ", ", \
                    len(xform[1][39]), "]"
            print xform.shape
            transforms.append(BinnedTensorTransform(input_names=input_names,
                              output_name=output_name,
                              input_binning=self.input_binning,
                              output_binning=self.output_binning,
                              xform_array=xform))
        print "transforms[", len(transforms), ", ", len(transforms[0].xform_array), \
                ", ", len(transforms[0].xform_array[0]), ", ", \
                len(transforms[0].xform_array[0][0]), "]"
        print transforms[0].xform_array.shape
        print "Generate Tset"
        Tset = TransformSet(transforms=transforms)
        print "Write to file"
        Tset.to_json('TsetRewrapped.json')
        print "Finished"
        return Tset





        ## In BargerPropagator code, it takes the "atmospheric
        ## mass difference"-the nearest two mass differences, so
        ## that it takes as input deltam31 for IMH and deltam32
        ## for NMH
        #m_atm = deltam31 if deltam31 < 0.0 else (deltam31 - deltam21)

        ## `:` slices for all binning dimensions (except true_energy and coszen,
        ## which get populated with their integer indices inside the for loop).
        ## Used to duplicate the oscillation E,CZ result to all other dimensions
        ## present in the binning
        #indexer = [slice(None)]*self.input_binning.num_dims

        #nu_xform, antinu_xform = self.create_transforms_datastructs()
        #for i, (true_energy, true_coszen) in enumerate(product(self.e_centers, self.cz_centers)):
            ## Construct indices in true_energy and true_coszen; populate to indexer
            #indexer[self.e_dim_num] = i // self.num_czbins
            #indexer[self.cz_dim_num] = i - indexer[self.e_dim_num] * self.num_czbins

            ## The final element must be populated with K_{ANTI}NEUTRINOS
            #mns_args = [sin2th12Sq, sin2th13Sq, sin2th23Sq, deltam21, m_atm, deltacp, true_energy, K_SQUARED, 0]

            #self.barger_propagator.DefinePath(true_coszen, prop_height, YeI, YeO, YeM)

            ## Neutrinos
            #mns_args[-1] = K_NEUTRINOS
            #self.barger_propagator.SetMNS(*mns_args)
            #self.barger_propagator.propagate(K_NEUTRINOS)
            #[setitem(nu_xform, tuple([out_idx, in_idx] + indexer), self.barger_propagator.GetProb(in_idx, out_idx)) for in_idx, out_idx in iter(INPUTS_OUTPUTS)]

            ## Antineutrinos
            #mns_args[-1] = K_ANTINEUTRINOS
            #self.barger_propagator.SetMNS(*mns_args)
            #self.barger_propagator.propagate(K_ANTINEUTRINOS)
            #[setitem(antinu_xform, tuple([out_idx, in_idx] + indexer), self.barger_propagator.GetProb(in_idx, out_idx)) for in_idx, out_idx in iter(INPUTS_OUTPUTS)]

        ## Slice up the transform arrays into views to populate each transform
        #transforms = []
        #for out_idx, output_name in enumerate(self.output_names):
            #out_idx = out_idx % 3
            #if 'bar' not in output_name:
                #xform = nu_xform[out_idx, :, ...]
                #input_names = self.input_names[0:2]
            #else:
                #xform = antinu_xform[out_idx, :, ...]
                #input_names = self.input_names[2:4]

            #transforms.append(BinnedTensorTransform(input_names=input_names, output_name=output_name, input_binning=self.input_binning, output_binning=self.output_binning, xform_array=xform))

        #return TransformSet(transforms=transforms)

    def validate_params(self, params):
        pass
