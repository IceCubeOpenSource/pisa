"""
The purpose of this stage is to load in events generated from Monte Carlo
simulations.

This service in particular reads in from files belonging to the GRECO
event sample. More information about this event sample can be found on
https://wiki.icecube.wisc.edu/index.php/IC86_Tau_Appearance_Analysis
"""
import numpy as np
import pint; ureg = pint.UnitRegistry()

from pisa.core.stage import Stage
from pisa.core.map import Map
from pisa.core.transform import BinnedTensorTransform, TransformSet
from pisa.core.binning import OneDimBinning, MultiDimBinning
from pisa.utils.fileio import from_file
from pisa.utils.flavInt import NuFlavIntGroup, flavintGroupsFromString
from pisa.utils.hash import hash_obj
from pisa.utils.log import logging
from pisa.utils.profiler import profile


class greco(Stage):
    """mc service to load in events from the GRECO event sample.

    Parameters
    ----------
    params: ParamSet of sequence with which to instantiate a ParamSet
        Parameters which set everything besides the binning

        Parameters required by this service are
            * mc_sample_config : filepath
                Filepath to event sample configuration

            * livetime : ureg.Quantity
                Desired lifetime.

    output_binning : MultiDimBinning or convertible thereto
        The binning desired for the output maps.

    transform_groups : string
        Specifies which particles/interaction types to use for computing the
        transforms.

    error_method : None, bool, or string
        If None, False, or empty string, the stage does not compute errors for
        the transforms and does not apply any (additional) error to produce its
        outputs. (If the inputs already have errors, these are propagated.)

    debug_mode : None, bool, or string
        If None, False, or empty string, the stage runs normally.
        Otherwise, the stage runs in debug mode. This disables caching (forcing
        recomputation of any nominal transforms, transforms, and outputs).

    disk_cache : None, str, or DiskCache
        If None, no disk cache is available.
        If str, represents a path with which to instantiate a utils.DiskCache
        object. Must be concurrent-access-safe (across threads and processes).

    transforms_cache_depth
    outputs_cache_depth : int >= 0

    Output Names
    ----------
    The `outputs` container generated by this service will be objects with the
    following `name` attribute:
        * 'nue_cc+nuebar_cc'
        * 'numu_cc+numubar_cc'
        * 'nutau_cc+nutaubar_cc'
        * 'nuall_nc+nuallbar_nc'
        * 'muongun'
        * 'noise'

    """
    def __init__(self, params, output_binning, output_names, transform_groups,
                 error_method=None, debug_mode=None, disk_cache=None,
                 transforms_cache_depth=20, outputs_cache_depth=20):
        expected_params = (
            'mc_sample_config', 'livetime', 'variables', 'weight'
        )

        self.output_groups = flavintGroupsFromString(transform_groups)
        self.config = from_file(params['mc_sample_config'].value)

        super(self.__class__, self).__init__(
            use_transforms=True,
            params=params,
            expected_params=expected_params,
            output_names=output_names,
            error_method=error_method,
            disk_cache=disk_cache,
            outputs_cache_depth=outputs_cache_depth,
            transforms_cache_depth=transforms_cache_depth,
            output_binning=output_binning,
            debug_mode=debug_mode
        )

        self.include_attrs_for_hashes('output_groups')

    def _compute_nominal_outputs(self):
        """Compute nominal histograms for output channels."""
        def parse(string):
            return string.replace(' ', '').split(',')
        event_types = parse(self.config.get('general', 'event_type'))

        nu_outputs = {}
        for ev_type in event_types:
            if 'neutrino' in ev_type:
                flavours = parse(self.config.get(ev_type, 'flavours'))
                sys_list = parse(self.config.get(ev_type, 'sys_list'))
                base_suffix = parse(self.config.get(ev_type, 'base_suffix'))
                for flav in flavours:
                    prefixes = []
                    for sys in sys_list:
                        ev_sys = ev_type + ':' + sys
                        nominal = float(self.config.get(ev_sys, 'nominal'))
                        ev_sys_nom = ev_sys + ':' + nominal
                        prefixes.append(self.config.get(ev_sys_nom,
                                                        'file_prefix'))
                    if len(set(prefixes)) > 1:
                        raise AssertionError(
                            'Choice of nominal file is ambigous. Nominal '
                            'choice of systematic parameters must coincide '
                            'with one and only one file. Options found are: '
                            '{0}'.format(prefixes)
                        )
                    file_prefix = flav + list(set(prefixes))[0]
                    events_file = self.config.get(base_suffix + file_prefix)

                    f = int(flav)
                    nu_outputs[NuFlavIntGroup(f, -f)] = from_file(events_file)

        nu_cc_outputs = {}
        for flavint_group in nu_outputs.iterkeys():
            cc_mask = nu_outputs[flavint_group]['ptype'] > 0

            cc_group = flavint_group.ccFlavInts()
            nu_cc_outputs[cc_group] = {}
            for var in nu_outputs[flavint_group].iterkeys():
                nu_outputs_perint[cc_group][var] = \
                        nu_outputs[flavint_group][var][cc_mask]

        nu_nc_outputs = {}
        for flavint_group in nu_outputs_perint.iterkeys():
            nc_mask = nu_outputs[flavint_group]['ptype'] < 0

            for var in nu_outputs[flavint_group].iterkeys():
                if nu_nc_outputs.has_key(var):
                    nu_nc_outputs[var] = np.concatenate((
                        nu_nc_outputs[var],
                        nu_outputs_perint[flavint_group][var][nc_mask]
                    ))
                else:
                    nu_nc_outputs[var] = nu_outputs_perint[flavint_group][var]

    def _histogram(events):
        """Histogram the events given the input binning."""
        #TODO(shivesh): reco or true?

    @profile
    def _compute_outputs(self, inputs=None):
        """Compute histograms for output channels."""
        # TODO(shivesh): this
        return self._compute_nominal_outputs()

    def validate_params(self, params):
        assert isinstance(params['mc_sample_config'].value, basestring)
        assert isinstance(params['variables'].value, basestring)
        assert isinstance(params['bool'].value, bool)
